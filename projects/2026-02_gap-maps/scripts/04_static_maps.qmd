---
title: "GAP Status Static Maps"
format: html
execute:
  echo: true
  warning: false
  message: false
---

```{r}
suppressPackageStartupMessages({
  cwd <- getwd()
  project_root <- if (basename(cwd) == "scripts") {
    normalizePath(file.path(cwd, ".."), mustWork = FALSE)
  } else {
    normalizePath(file.path(cwd, "projects", "2026-02_gap-maps"), mustWork = FALSE)
  }
  project_lib <- file.path(project_root, ".Rlib")
  if (dir.exists(project_lib)) {
    .libPaths(c(project_lib, .libPaths()))
  }
  if (!requireNamespace("tigris", quietly = TRUE)) {
    if (!dir.exists(project_lib)) {
      dir.create(project_lib, recursive = TRUE, showWarnings = FALSE)
    }
    install.packages("tigris", repos = "https://cloud.r-project.org", lib = project_lib)
    .libPaths(c(project_lib, .libPaths()))
  }
  if (!requireNamespace("rmapshaper", quietly = TRUE)) {
    if (!dir.exists(project_lib)) {
      dir.create(project_lib, recursive = TRUE, showWarnings = FALSE)
    }
    install.packages("rmapshaper", repos = "https://cloud.r-project.org", lib = project_lib)
    .libPaths(c(project_lib, .libPaths()))
  }
  if (!requireNamespace("gridExtra", quietly = TRUE)) {
    if (!dir.exists(project_lib)) {
      dir.create(project_lib, recursive = TRUE, showWarnings = FALSE)
    }
    install.packages("gridExtra", repos = "https://cloud.r-project.org", lib = project_lib)
    .libPaths(c(project_lib, .libPaths()))
  }
  library(sf)
  library(dplyr)
  library(ggplot2)
  library(tigris)
  if (requireNamespace("rmapshaper", quietly = TRUE)) {
    library(rmapshaper)
  }
  if (requireNamespace("gridExtra", quietly = TRUE)) {
    library(gridExtra)
  }
  library(grid)
})

cwd <- getwd()
project_root <- if (basename(cwd) == "scripts") {
  normalizePath(file.path(cwd, ".."), mustWork = FALSE)
} else {
  normalizePath(file.path(cwd, "projects", "2026-02_gap-maps"), mustWork = FALSE)
}

gpkg_path <- file.path(project_root, "data", "new_SSN_GAP.gpkg")
layer_name <- "new_SSN_GAP"
out_dir <- file.path(project_root, "outputs", "maps")

if (!dir.exists(out_dir)) {
  dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
}
if (!file.exists(gpkg_path)) {
  stop("GeoPackage not found at: ", gpkg_path)
}

sf_obj <- st_read(gpkg_path, layer = layer_name, quiet = TRUE)
attrs <- st_drop_geometry(sf_obj)

site_field <- if ("Property_n" %in% names(attrs)) "Property_n" else "Property_1"
owner_field <- if ("Organizati" %in% names(attrs)) "Organizati" else NA_character_
gap_field <- if ("reGAP" %in% names(attrs)) "reGAP" else NA_character_

if (is.na(owner_field) || is.na(gap_field)) {
  stop("Owner or GAP field not found.")
}

options(tigris_use_cache = TRUE)
ca <- tigris::states(cb = TRUE, year = 2023, class = "sf") %>%
  filter(NAME == "California") %>%
  st_transform(st_crs(sf_obj))

# Simplify for cleaner aesthetics, preserve topology when available
if (requireNamespace("rmapshaper", quietly = TRUE)) {
  ca <- rmapshaper::ms_simplify(ca, keep = 0.08, keep_shapes = TRUE)
}

gap_levels <- c("1", "2", "3", "4", "Unprotected")
sf_obj$gap_display <- ifelse(as.character(sf_obj[[gap_field]]) == "0", "Unprotected", as.character(sf_obj[[gap_field]]))
sf_obj$gap_display <- factor(sf_obj$gap_display, levels = gap_levels)
sf_obj$owner_display <- sf_obj[[owner_field]]

gap_palette <- c(
  "1" = "#0B6E4F",
  "2" = "#F2C300",
  "3" = "#F28E1C",
  "4" = "#C81D25",
  "Unprotected" = "#4B2E83"
)

plot_map <- function(data_sf, title) {
  ggplot() +
    geom_sf(data = ca, fill = "white", color = "#BFC5C8", linewidth = 0.4) +
    geom_sf(
      data = data_sf,
      aes(color = gap_display),
      size = 1.8,
      alpha = 0.85
    ) +
    scale_color_manual(values = gap_palette, drop = FALSE, limits = gap_levels, name = "GAP Status") +
    coord_sf() +
    labs(title = title) +
    theme_minimal(base_size = 12) +
    theme(
      panel.grid = element_blank(),
      axis.title = element_blank(),
      axis.text = element_blank(),
      legend.position = c(0.06, 0.08),
      legend.justification = c(0, 0),
      plot.title = element_text(face = "bold", size = 16, hjust = 0.1)
    )
}

make_counts_table <- function(data_sf) {
  counts <- data_sf %>%
    st_drop_geometry() %>%
    count(gap_display, sort = FALSE)

  all_levels <- data.frame(gap_display = factor(gap_levels, levels = gap_levels))
  counts <- merge(all_levels, counts, by = "gap_display", all.x = TRUE)
  counts$n[is.na(counts$n)] <- 0
  counts$gap_display <- as.character(counts$gap_display)
  counts
}

gap_definitions_text <- paste(
  "GAP Definitions:",
  "",
  "1: An area having permanent protection from conversion of natural land cover and a",
  "   mandated management plan in operation to maintain a natural state within which",
  "   disturbance events (of natural type, frequency, intensity, and legacy) are allowed",
  "   to proceed without interference or are mimicked through management.",
  "",
  "2: An area having permanent protection from conversion of natural land cover and a",
  "   mandated management plan in operation to maintain a primarily natural state, but",
  "   which may receive uses or management practices that degrade the quality of",
  "   existing natural communities, including suppression of natural disturbance.",
  "",
  "3: An area having permanent protection from conversion of natural land cover for the",
  "   majority of the area, but subject to extractive uses of either a broad, low",
  "   intensity type (for example, logging, Off-Highway Vehicle recreation) or localized",
  "   intense type (for example, mining). It also confers protection to federally listed",
  "   endangered and threatened species throughout the area.",
  "",
  "4: There are no known public or private institutional mandates, or legally recognized",
  "   easements or deed restrictions held by the managing entity to prevent conversion",
  "   of natural habitat types to anthropogenic habitat types. The area generally allows",
  "   conversion to unnatural land cover throughout or management intent is unknown.",
  "",
  "Unprotected: No formal protection.",
  sep = "\n"
)

compose_panel <- function(data_sf, title) {
  map_plot <- plot_map(data_sf, title)
  counts <- make_counts_table(data_sf)
  counts_df <- data.frame(
    GAP = counts$gap_display,
    `# Sites` = counts$n,
    check.names = FALSE
  )

  defs_grob <- grid::textGrob(
    gap_definitions_text,
    x = 0,
    y = 0.35,
    hjust = 0,
    vjust = 0.5,
    gp = grid::gpar(fontsize = 9, col = "#333333", lineheight = 1.25)
  )

  table_grob <- gridExtra::tableGrob(
    counts_df,
    rows = NULL,
    theme = gridExtra::ttheme_minimal(
      core = list(
        fg_params = list(fontsize = 11),
        bg_params = list(fill = c("white", "#F5F5F5"))
      ),
      colhead = list(
        fg_params = list(fontsize = 11, fontface = "bold"),
        bg_params = list(fill = "#EFEFEF")
      ),
      padding = grid::unit(c(2, 2), "mm")
    )
  )

  right_panel <- gridExtra::arrangeGrob(
    grid::nullGrob(),
    defs_grob,
    grid::nullGrob(),
    table_grob,
    ncol = 1,
    heights = c(0.35, 0.45, 0.35, 1.0),
    padding = grid::unit(0, "pt")
  )

  gridExtra::arrangeGrob(
    map_plot,
    right_panel,
    ncol = 2,
    widths = c(2.8, 2.2),
    heights = c(1)
  )
}

save_map <- function(plot_obj, filename) {
  ggsave(
    filename = file.path(out_dir, filename),
    plot = plot_obj,
    width = 11,
    height = 8.5,
    dpi = 300
  )
}
```

## All Sites

```{r}
all_panel <- compose_panel(sf_obj, "All Sentinel Sites")
save_map(all_panel, "gap_all_sites.png")
all_panel
```

## By Owner

```{r}
owners <- sort(unique(sf_obj$owner_display))
owners <- owners[!is.na(owners)]

for (o in owners) {
  owner_sf <- sf_obj %>% filter(owner_display == o)
  owner_title <- paste0(o, " Sentinel Sites")
  p <- compose_panel(owner_sf, owner_title)
  safe_name <- gsub("[^A-Za-z0-9]+", "_", o)
  save_map(p, paste0("gap_owner_", safe_name, ".png"))
  print(p)

  knitr::kable(gap_explainer, caption = "GAP status definitions (0 = unprotected in this dataset)")

  gap_counts_owner <- owner_sf %>%
    st_drop_geometry() %>%
    count(gap_display, sort = TRUE)

  knitr::kable(gap_counts_owner, caption = paste("Count by GAP status â€”", o))
}
```
